<div class="playerPage"></div>
<div id="popupHolder" class="container-fluid d-flex flex-column justify-content-center">
	<div class="prev"></div>
	<div class="next"></div>
	<div class="row d-flex justify-content-center">
		<div class="col">
			<div id="spotifyUpdate" class="spotifyUpdate">
				<!-- <img id="artwork" alt="current album artwork"> -->
				<h3 id="title" class="text-white"></h3>
				<h6 id="artist" class="text-white"></h6>
			</div>
		</div>
	</div>
	<div class="trackposition" id="trackposition">
		<div class="fill" id="trackpositionfill"></div>
	</div>
</div>

<script>
	// auth
	let CLIENT_ID = "<%= Rails.application.secrets.SPECTRIFY_CLIENT_ID %>";
	const accessToken = "<%= @current_user.access_token %>";

	// player state
	let artistName = "";
	let albumName = "";
	let albumArt = "";
	let trackDuration = 180000;
	let trackURI = "";
	let trackPosition = 0;
	let trackPlaying = false;
	let trackName = "";
	let currentTrack = null;
	// playhead location
	let lastTrackPositionUpdate = 0;

	let pollDebounce = 0;

	// misc ui
	let closetimer = 0;
	let fadeinTime = 10000;
	let fadeoutTime = 4000;

	// --------------------------------------------------------------------------------------
	// network - XMLborrowed from github.com/jamescastells - LIFE SAVER!
	// --------------------------------------------------------------------------------------
	function createRequest( method, url, onload ) {
		let request = new XMLHttpRequest();
		request.open(method, url);
		if (method != "GET") {
			request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
		}
		request.onerror = function () {
			console.error("An error occured during the request.");
		};
		request.onload = onload.bind(this, request);
		return request;
	};

	function createAuthorizedRequest( method, url, onload ) {
		let request = createRequest( method, url, onload );
		request.setRequestHeader( "Authorization", "Bearer " + accessToken );
		return request;
	};

	// NFI how this works... binding a setTimeout?
	function _pollCurrentlyPlaying( callback ) {
		createAuthorizedRequest("GET", "https://api.spotify.com/v1/me/player/currently-playing", function ( request ) {
			if ( request.status < 200 || request.status >= 400 ) {
				callback();
				return;
			};

			let data = JSON.parse( request.responseText );
			console.log("Current track:", data );
			if ( data.item ) {
				trackName = data.item.name;
				albumName = data.item.album.name;
				albumArt = data.item.album.images[2].url;
				artistName = data.item.artists[0].name;
				setNowPlayingTrack(data.item);
				trackPosition = data.progress_ms;
				trackDuration = data.item.duration_ms;
				trackPlaying = data.is_playing
			};
			callback();
		} ).send();
	};

	// NFI how this works... binding a setTimeout?
	function pollCurrentlyPlaying( delay ) {
		if ( pollDebounce ) {
			clearTimeout( pollDebounce );
		}
		pollDebounce = setTimeout( _pollCurrentlyPlaying.bind( this, pollCurrentlyPlaying.bind( this ) ), delay || 5000 );
	};

	function getUserInformation( callback ) {
		createAuthorizedRequest( "GET", "https://api.spotify.com/v1/me", function ( request ) {
			if ( request.status < 200 || request.status >= 400 ) {
				callback(null);
				return;
			}

			console.log( "User info retrieved:", request.responseText );
			let data = JSON.parse( request.responseText );
			callback( data );
		} ).send();
	};

	function fetchArtist( artist_uri, callback ) {
		console.log( "fetching artist", artist_uri );
		let artistId = artist_uri.split(":")[2];
		createAuthorizedRequest( "GET", "https://api.spotify.com/v1/artists/" + artistId, function ( request ) {
			if ( request.status >= 200 && request.status < 400 ) {
				let data = JSON.parse(request.responseText);
				callback( data );
			}
		} ).send();
	};

	// --------------------------------------------------------------------------------------
	// commands for playback
	// --------------------------------------------------------------------------------------
	function sendCommand( method, command, querystring ) {
		// console.log( "method: " + method );
		console.log( "command: " + command );
		// console.log( "querystring: " + querystring );
		let url = "https://api.spotify.com/v1/me/player/" + command + ( ( querystring ) ? ( "?" + querystring ) : "" );
		// console.log( url )
		createAuthorizedRequest( method, url, function ( request ) {
			if ( request.status >= 200 && request.status < 400 ) {
				// console.log("command response:", request.responseText);
			};
			pollCurrentlyPlaying( 1500 );
		} ).send();
	};

	// skip forward in song by clicking on progress bar
	function sendPlayContext( uri, offset ) {
		sendPlayCommand( {
			context_uri: uri,
			offset: {
				position: offset || 0
			}
		} );
	}

	// --------------------------------------------------------------------------------------
	// DOM manip
	// --------------------------------------------------------------------------------------
	function updateTrackPosition() {
		// get the current time
		let time = ( new Date() ).getTime();

		// if global variable not set, set to time just acquired
		if ( lastTrackPositionUpdate == 0 ) {
			lastTrackPositionUpdate = time;
		};

		// calc the difference between last update and time just acquired
		let elapsedTime = time - lastTrackPositionUpdate;
		// update new global time to time just acquired, so next pass references it
		lastTrackPositionUpdate = time;

		// track playing is update from _pollCurrentlyPlaying
		if ( trackPlaying ) {
			trackPosition += elapsedTime;
		};

		let playheadLocation = trackPosition * 100 / trackDuration;
		playheadLocation = Math.max( Math.min( 100, playheadLocation ), 0 );
		document.getElementById( "trackpositionfill" ).style.width = playheadLocation + "%";
	}

	function notificationPopup( title, subtitle, artwork ) {
		document.getElementById( "title" ).innerText = title || "";
		document.getElementById( "artist" ).innerText = subtitle || "";
		// document.getElementById( "artwork" ).src = artwork || "";
		$( "#spotifyUpdate" ).addClass("visible");

		clearTimeout( closetimer );
		closetimer = setTimeout( function () {
			$( "#spotifyUpdate" ).removeClass( "visible" );
		}, 5000 );
	}

	function setNowPlayingTrack( track ) {
		if ( track.uri == trackURI ) {
			return;
		}
		currentTrack = track;
		trackURI = track.uri;
		notificationPopup( trackName, artistName + " - " + albumName, albumArt );
	}

	function connect() {
		// console.log( "Connecting with access token: " + accessToken );
		console.log("Retrieving user info.");
		getUserInformation( function ( userinfo ) {
			if ( !userinfo ) {
				accessToken = "";
				return;
			}

			notificationPopup("Hello " + ( userinfo.display_name || userinfo.id ) + "!", "Make sure you\'re playing something in Spotify!");
			console.log("Connecting to stream...")
			pollCurrentlyPlaying( 2000 );
		} );
	}

	function initUI() {
		document.getElementById( "trackposition" ).addEventListener("mousedown", function ( event ) {
			let time = event.offsetX * trackDuration / document.body.offsetWidth;
			trackPosition = time;
			sendCommand( "PUT", "seek", "position_ms=" + Math.round( time ) );
		});

		setInterval( updateTrackPosition, 1000 );
	}

	// setup keyboard for playback commands
	function initKeyboard() {
		window.addEventListener("keyup", function ( event ) {
			// left
			if ( event.keyCode === 37 ) {
				console.log("Prev...");
				sendCommand("POST", "previous");
			}
			// right
			if ( event.keyCode === 39 ) {
				console.log("Next...");
				sendCommand("POST", "next");
			}
			// space
			if ( event.keyCode === 32 ) {
				if (trackPlaying) {
					console.log("Pausing...");
					trackPlaying = false;
					sendCommand("PUT", "pause");
				} else {
					console.log("Playing...");
					trackPlaying = true;
					sendCommand("PUT", "play");
				}
			}
		});
	}

	// --------------------------------------------------------------------------------------
	// fireItUp
	// --------------------------------------------------------------------------------------
	function fireItUp() {
		initKeyboard();
		initUI();
		connect();
	}

	window.addEventListener( "load", fireItUp );
</script>